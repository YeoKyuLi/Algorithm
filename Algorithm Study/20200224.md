# 1. [1343] Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold

[site](https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)

Given an array of integers `arr` and two integers `k` and `threshold`.

Return *the number of sub-arrays* of size `k` and average greater than or equal to `threshold`.

 

**Example 1:**

```
Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3
Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
```

**Example 2:**

```
Input: arr = [1,1,1,1,1], k = 1, threshold = 0
Output: 5
```

**Example 3:**

```
Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6
Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.
```

**Example 4:**

```
Input: arr = [7,7,7,7,7,7,7], k = 7, threshold = 7
Output: 1
```

**Example 5:**

```
Input: arr = [4,4,4,4], k = 4, threshold = 1
Output: 1
```



#### 1

```c++
class Solution {
public: 
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int answer=0;
        int tmp=0;
        
        for(int i = 0 ; i < arr.size(); i++)
        {
            tmp += arr[i];
            if(i >= k)
            {
                tmp -= arr[i-k];
            }
            if((i >= k-1) &&(tmp / k ) >= threshold)
                answer++;
            
        }
        
        return answer;
    }
};
```

```c++
int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int res = 0, sum = 0, t = k * threshold;
        for (int i = 0; i < arr.size(); i++) {
            sum += arr[i];
            if (i >= k) {
                sum -= arr[i-k];
            }
            if (i >= k-1 && sum >=t) {
                res++;
            }
        }
        return res;
    }
```





# 2. Max Area of Island

[site](https://leetcode.com/problems/max-area-of-island/)

Given a non-empty 2D array `grid` of 0's and 1's, an **island** is a group of `1`'s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)

**Example 1:**

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```

Given the above grid, return `6`

**Example 2:**

```
[[0,0,0,0,0,0,0,0]]
```

Given the above grid, return `0`

**Note:** The length of each dimension in the given `grid` does not exceed 50.



#### 1round

```c++
class Solution {
private:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};
    
    int cntIsland(int _x, int _y, vector<vector<int>>& grid)
    {
        queue<pair<int,int>> que;
        que.push({_x, _y});
        int space = 1, width = grid.size(), height = grid[0].size();
        grid[_x][_y] = 0;
        
        while(!que.empty())
        {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for(int i = 0; i < 4; i++)
            {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx >= 0 && ny >= 0 && nx < width && ny < height)
                {
                    if(grid[nx][ny] == 1)
                    {
                        que.push(make_pair(nx,ny));
                        grid[nx][ny] = 0;
                        space++;
                    }
                }
            }
        }

        return space;
    }
    
public: 
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int ans = 0;
    
        for(int i = 0; i < grid.size(); i++)
        {
            for(int j = 0; j <grid[i].size(); j++)
            {
                if(grid[i][j] == 1)
                    ans = max(ans, cntIsland(i, j, grid));
            }
        }
        
        return ans;
    }
};
```



# 3 가장 긴 팰린드롬

[site](https://programmers.co.kr/learn/courses/30/lessons/12904)

###### 문제 설명

앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다.
문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요.

예를들면, 문자열 s가 abcdcba이면 7을 return하고 abacde이면 3을 return합니다.

##### 제한사항

- 문자열 s의 길이 : 2,500 이하의 자연수
- 문자열 s는 알파벳 소문자로만 구성

------

##### 입출력 예

| s       | answer |
| ------- | ------ |
| abcdcba | 7      |
| abacde  | 3      |

##### 입출력 예 설명

입출력 예 #1
4번째자리 'd'를 기준으로 문자열 s 전체가 팰린드롬이 되므로 7을 return합니다.

입출력 예 #2
2번째자리 'b'를 기준으로 aba가 팰린드롬이 되므로 3을 return합니다.



문제 정의도 제대로 안했음.
함수 이름 정의가 필요함.
논리가 정리가 안됨.
테스트 케이스가 없음.
스켈레톤 코드 없이 바로 구현을 하려함.
C++ ← 본인 사용하려는 함수의 정확용도를 모름.



#### 1

```c++
#include <iostream>
#include <string>
using namespace std;

string modifyStr(string s)
{
    string k = "#";
    for(int i = 0 ; i <s.length(); i++)
    {
        k += s[i];
        k += '#';
    }
    
    return k;
}

int solution(string s)
{
    int answer=0;
    string newStr = modifyStr(s);
    int oriLen = s.length();
    int strLen = newStr.length();
    int left, right, myLog=0;
    for(int i = 0; i < newStr.length(); i++)
    {
        left = right = i;
        myLog=0;
        while(left > 0 && right < strLen)
        {
        if(newStr[--left] == newStr[++right])
            myLog++;
        else
            break;
        }
        if(answer < myLog)
            answer = myLog;
        if(answer == strLen-1)
            break;
    }

    return answer;
}
```







# 4. Tree: Height of a Binary Tree

[site](https://www.hackerrank.com/challenges/tree-height-of-a-binary-tree/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=trees)

The height of a binary tree is the number of edges between the tree's root and its furthest leaf. For example, the following binary tree is of height :

![image](https://s3.amazonaws.com/hr-assets/0/1527626183-88c8070977-isitBSTSample0.png)
**Function Description**

Complete the *getHeight* or *height* function in the editor. It must return the height of a binary tree as an integer.

getHeight or height has the following parameter(s):

- *root*: a reference to the root of a binary tree.

**Note** -The Height of binary tree with single node is taken as zero.

**Input Format**

The first line contains an integer , the number of nodes in the tree.
Next line contains space separated integer where th integer denotes node[i].data.

**Note**: Node values are inserted into a binary search tree before a reference to the tree's root node is passed to your function. In a binary search tree, all nodes on the left branch of a node are less than the node value. All values on the right branch are greater than the node value.

**Constraints**



**Output Format**

Your function should return a single integer denoting the height of the binary tree.

**Sample Input**

![image](https://s3.amazonaws.com/hr-assets/0/1527625966-0f80a8e1a4-treeDepthSample0.png)

**Sample Output**

```
3
```

**Explanation**

The longest root-to-leaf path is shown below:

![image](https://s3.amazonaws.com/hr-assets/0/1527626088-807ca5fc63-treeDepthSample1.png)

There are nodes in this path that are connected by edges, meaning our binary tree's .





#### 1 ground

```c++
#include <bits/stdc++.h>

using namespace std;

class Node {
    public:
        int data;
        Node *left;
        Node *right;
        Node(int d) {
            data = d;
            left = NULL;
            right = NULL;
        }
};

class Solution {
    public:
  		Node* insert(Node* root, int data) {
            if(root == NULL) {
                return new Node(data);
            } else {
                Node* cur;
                if(data <= root->data) {
                    cur = insert(root->left, data);
                    root->left = cur;
                } else {
                    cur = insert(root->right, data);
                    root->right = cur;
               }

               return root;
           }
        }
/*The tree node has data, left child and right child 
class Node {
    int data;
    Node* left;
    Node* right;
};
*/
    int maxLen=0, ans=0;
    int findLeftLength(Node* root)
    {
        int res=0;
        // cout << "Left :" << endl;
        while(root != nullptr)
        {
            // cout << root->data << " ";
            root = root->left;
            res++;
        }
        // cout << endl;
        return res;
    }
    int findRightLength(Node* root)
    {
        int res=0;
        // cout << "Right :" << endl;
        while(root != nullptr)
        {
            // cout << root->data << " ";
            root = root->right;
            res++;
        }
        // cout << endl;
        return res;
    }
    void preOrder(Node* root)
    {
        if(root == nullptr)
            return;
        maxLen = max(findRightLength(root), findLeftLength(root));
        if(maxLen > ans)
            ans = maxLen;
        preOrder(root->left);
        preOrder(root->right);
    }
    int height(Node* root) {
        // Write your code here.
        preOrder(root);
        return ans-1;
    }

}; //End of Solution
```



#### 2round

```c++
 int height(Node* root) {
        // Write your code here.
        if(root == nullptr)
            return -1;
        return max(height(root->left), height(root->right))+1;
    }
```

![image-20200226165305914](/Users/yeokyuli/Library/Application Support/typora-user-images/image-20200226165305914.png)

